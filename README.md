
# Data Treatment Interpreter

This repository contains a Go-based interpreter for parsing and applying transformations to structured data (JSON) using a custom lexer, parser, and transformer system. The interpreter allows you to define transformation commands in a simple DSL (Domain Specific Language) and apply them to JSON data, making it easy to manipulate and transform fields according to specific rules.

## Features

- **Custom Lexer**: Tokenizes commands written in the interpreterâ€™s DSL.
- **Parser**: Interprets the tokenized input and generates transformation commands.
- **Transformers**: Applies transformations such as `uppercase`, `concatenate`, `bmi`, and more on the JSON data fields.
- **Supports Iteration**: Allows iteration over arrays in the JSON data using placeholders.
- **Modular Design**: Easily extensible with new transformers and transformations.
- **Temporary Variables**: Allows the use of temporary variables for intermediate transformations, which are automatically deleted after the execution of the final command.
- **Informative Error Messages**: Both the lexer and parser provide detailed error messages with line numbers and position markers to make it easier to debug syntax errors.

## Project Structure

The project consists of four main components:

1. **Lexer** (`internal/lexer`): Tokenizes the input commands into different token types like `IDENTIFIER`, `STRING`, `OPERATOR` and `SYMBOLS`.
2. **Parser** (`internal/parser`): Parses the tokens from the lexer and constructs a `Program` struct that defines the transformations to apply.
3. **Engine** (`internal/engine`): Executes the parsed commands and applies the corresponding transformations to the input JSON data.
4. **Transformers** (`internal/transformers`): Implements different transformation functions such as `uppercase`, `concatenate`, and `bmi`.

## How It Works

### Lexer

The lexer reads the input command line by line and tokenizes it based on predefined rules. It recognizes keywords like `SET`, operators like `=`, and different token types such as strings and identifiers. The lexer emits tokens that are consumed by the parser.

#### **Lexer Error Handling**

If the lexer encounters an unexpected character or an invalid token, it emits an `ERROR` token with a detailed error message, including the line number and position in the input:

```plaintext
unexpected character '@'
```
The underlying token would be:
```go
Token{
	Type: ERROR,
	Literal: "unexpected character '@'",
	Line: 1,
	Position: 8
}
```

This helps pinpoint exactly where the invalid character occurred in the input, making it easier to debug syntax errors.

### Parser

The parser interprets the tokens emitted by the lexer and constructs a `Program` that represents the command. The parser is responsible for handling keywords, variable assignments, and the structure of transformation commands.

#### **Parser Error Handling**

The parser provides detailed, context-aware error messages when it encounters invalid syntax or unexpected tokens. It includes the line number, position, and highlights the exact location of the error with a pointer (`^`). For example:

```plaintext
unexpected token in variables at line 1, position 12
SET fullName@ = concatenate(' ',name, surname)
            ^
```

This type of informative error messaging makes it easy to spot where the issue lies in the command syntax.

### Engine

The engine is the core component that takes a `Program` generated by the parser and applies the transformations to the input JSON. It uses registered transformers to manipulate the JSON fields and return the modified result.

#### **Temporary Variables**

One powerful feature of the interpreter is the ability to use **temporary variables**. These variables, prefixed with an underscore (`_`), can be used to store intermediate results during the transformations. After all transformations are complete, these temporary variables are automatically deleted from the final JSON output.

Example:

```plaintext
SET _tempName = concatenate(' ', firstName, lastName)
SET fullName = uppercase(_tempName)
```

In this case, the `_tempName` variable is used to store the concatenation of the `firstName` and `lastName` fields. It is then converted to uppercase and stored in `fullName`, and finally, `_tempName` is deleted from the resulting JSON.

### Transformers

Transformers are responsible for applying specific transformations to the JSON fields. Examples include:
- **Uppercase**: Converts the value of a field to uppercase.
- **Concatenate**: Concatenates multiple strings with a separator.
- **BMI**: Calculates the Body Mass Index (BMI) based on weight and height fields in the JSON.

## Example DSL

Here is an example of a simple command in the interpreter's DSL:

```plaintext
SET name = uppercase(firstName)
```

This command will take the value of the `firstName` field from the input JSON and convert it to uppercase, assigning the result to `name`.

Another example for concatenation:

```plaintext
SET fullName = concatenate(' ', firstName, lastName)
```

This will concatenate the `firstName` and `lastName` fields with a space separator and store the result in `fullName`.

## Usage

1. Clone the repository:

    ```bash
    git clone https://github.com/codeis4fun/data-treatment-interpreter.git
    cd data-treatment-interpreter
    ```

2. Run the interpreter with the following command:

    ```bash
    make run
    ```
3. Run unit tests with the following command:

	```bash
	make test
	```

## Example

### Sample JSON Input

```json
{
	"firstName": "john",
	"lastName": "doe",
	"weight": 75,
	"height": 1.75,
	"favoriteFoods": [
		"pizza",
		"pasta",
		"sushi"
	],
	"favoriteColors": [
		"red",
		"blue",
		"green"
	],
	"place": "New York/USA",
	"friends": [
		{
			"name": "Alice"
		},
		{
			"name": "Bob"
		}
	]
}
```

### Sample Commands

```plaintext
SET _tempName = concatenate(' ', firstName, lastName)
SET fullName = uppercase(_tempName)
SET bmi, isHealty = bmi(weight, height)
SET favoriteFoods.0 = uppercase(favoriteFoods.0)
SET favoriteColors.# = uppercase(favoriteColors.#)
SET _city, _country = split(place, '/')
SET address.city = uppercase(_city)
SET address.country = uppercase(_country)
SET friends.#.name = uppercase(friends.#.name)
```

### Output

```json
{
	"firstName": "john",
	"lastName": "doe",
	"weight": 75,
	"height": 1.75,
	"favoriteFoods": [
		"PIZZA",
		"pasta",
		"sushi"
	],
	"favoriteColors": [
		"RED",
		"BLUE",
		"GREEN"
	],
	"place": "New York/USA",
	"friends": [
		{
			"name": "ALICE"
		},
		{
			"name": "BOB"
		}
	],
	"fullName": "JOHN DOE",
	"bmi": 24.5,
	"isHealty": true,
	"address": {
		"city": "NEW YORK",
		"country": "USA"
	}
}
```

### Temporary Variable Cleanup

In the above example, the `_tempName`, `_city` and `_country` variables were used for intermediate processing and are not part of the final JSON output. The interpreter automatically removes such temporary variables, ensuring a clean and meaningful output.

## Adding New Transformers

To add a new transformer, create a new struct in the `internal/transformers` package and implement the `Transform` method.

For example, to create a transformer that reverses strings:

```go
package transformers

import "github.com/tidwall/gjson"

type Reverse struct {
	Config
}

func (t *Reverse) Transform() (Results, error) {
	if len(t.Args) != 1 {
		return Results{}, errors.New("reverse transformer requires exactly one argument")
	}
	value := gjson.GetBytes(t.Json, t.Args[0])
	if !value.Exists() {
		return Results{}, errors.New("field does not exist")
	}

	if !value.IsString() {
		return Results{}, errors.New("field is not a string")
	}

	runes := []rune(value.String())
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return Results{string(runes)}, nil
}
```

Then register the transformer in the `internal/engine/engine.go` file.

```go
transformers := map[string]transformerConfig{
    "uppercase":   func(config transformers.Config) Transformer { return &transformers.Uppercase{Config: config} },
    "concatenate": func(config transformers.Config) Transformer { return &transformers.Concatenate{Config: config} },
    "reverse":     func(config transformers.Config) Transformer { return &transformers.Reverse{Config: config} },
}
```